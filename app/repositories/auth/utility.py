from datetime import timedelta, datetime, timezone
from typing import Any
import bcrypt
import jwt
import re
from enum import Enum, StrEnum, auto

# bcrypt requires the password to be encoded to bytes before hashing or checking.
# The salt is automatically generated by gensalt() and is included in the hash.
# Adjust the 'rounds' for the desired computational cost (default is 12).
BCRYPT_ROUNDS = 12


def get_password_hash(password: str) -> str:
    """
    Hashes the password using bcrypt. Returns the hashed password as a string.
    """
    # 1. Encode the password to bytes
    password_bytes = password.encode('utf-8')
    
    # 2. Generate a salt and hash the password
    # gensalt() generates a new salt with the specified rounds
    hashed_password_bytes = bcrypt.hashpw(
        password_bytes, 
        bcrypt.gensalt(rounds=BCRYPT_ROUNDS)
    )
    
    # 3. Decode the hash back to a string for storage
    return hashed_password_bytes.decode('utf-8')

def is_valid_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verifies the plain password against the hashed password.
    """
    # 1. Encode both the plain and hashed passwords to bytes
    # The bcrypt hash string already contains the salt and cost factor.
    plain_password_bytes = plain_password.encode('utf-8')
    hashed_password_bytes = hashed_password.encode('utf-8')

    # 2. Use checkpw() for safe comparison
    # It automatically extracts the salt from the hash and performs the check.
    # Note: bcrypt.checkpw is safer than manually using bcrypt.hashpw + comparison
    return bcrypt.checkpw(plain_password_bytes, hashed_password_bytes)



def create_access_token(data: dict[str, Any],key : str, algorithm: str, expires_delta: timedelta | None = None, ) ->str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})

    encoded_jwt = jwt.encode(to_encode,key = key, algorithm = algorithm) # type: ignore
    return encoded_jwt

